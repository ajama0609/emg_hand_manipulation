    %file = readtable("emg_data_1.csv");
    time = file{:,1};           % First column = Time (ms)
    channels = file{:, 2:9};    % Columns 2-9 = Channel 1 to 8
    gesture_class = file{:, 10}; % Class labels (0 to 7)
    
    % Parameters
    window_size = 200;    % in samples
    step_size = 100;      % in samples
    threshold = 2e-4;
    num_samples = size(channels, 1);
    
    % Initialize cleaned windows and labels storage
    cleaned_windows = {};
    cleaned_labels = [];
    window_times = {};
    
    for start_idx = 1:step_size:(num_samples - window_size + 1)
        end_idx = start_idx + window_size - 1;
        window = channels(start_idx:end_idx, :);
        
        % Zero out samples below threshold
        window(abs(window) < threshold) = 0;
        
        % Keep all windows, even if some samples are zeroed
        cleaned_windows{end+1} = window;
        window_times{end+1} = time(start_idx:end_idx);
        cleaned_labels(end+1) = gesture_class(start_idx + floor(window_size/2));
    end
    
    % Butterworth bandpass filter design
    Fs = 1000;  % Sampling frequency (Hz)
    order = 2;
    low_cutoff = 20;
    high_cutoff = 450;
    Wn = [low_cutoff high_cutoff] / (Fs/2);
    [b, a] = butter(order, Wn, 'bandpass');
    
    f0 = 50;    % Notch frequency
    bw = 2;     % Bandwidth around notch frequency (Hz)
    
    % Calculate normalized frequencies for bandstop
    W1 = (f0 - bw/2) / (Fs/2);
    W2 = (f0 + bw/2) / (Fs/2);
    
    [b_notch, a_notch] = butter(2, [W1 W2], 'stop');
    
    num_windows = length(cleaned_windows);
    num_channels = size(cleaned_windows{1}, 2);
    
    % Preallocate filtered windows and RMS feature matrix
    filtered_windows = cell(num_windows, 1);
    
    % Filter each window and compute RMS per channel
    for w = 1:num_windows
        window = cleaned_windows{w};
        filtered_window = zeros(size(window));
        
        for ch = 1:num_channels
            y = window(:, ch);
            
            % Apply notch filter first to remove 50 Hz interference
            y_notched = filtfilt(b_notch, a_notch, y);
            
            % Then apply bandpass filter
            y_filtered = filtfilt(b, a, y_notched);
            
            % Threshold after filtering (optional)
            y_filtered(abs(y_filtered) < threshold) = 0;
            
            filtered_window(:, ch) = y_filtered;
        end
        
        filtered_windows{w} = filtered_window;
    end
     
    
    colors = lines(num_channels);
    figure; hold on;
    
    NFFT=1000; 
    %ch=1; 
    %num_windows=200;
    %for ch = 1:num_channels
        mags = zeros(num_windows, NFFT/2+1);
        for w = 1:num_windows
            y = filtered_windows{w}(:, 1);    % get filtered data of window w, channel ch
            Y = fft(y, NFFT) / length(y);      % FFT normalized by window length
            mags(w, :) = 2 * abs(Y(1:NFFT/2+1)); % single-sided magnitude spectrum
        end
        avg_mag(1, :) = mean(mags, 1);       % average across windows
    %end
    
    figure; hold on;
    freq = linspace(0, Fs/2, NFFT/2+1);
    %for ch = 1:num_channels
        plot(freq, avg_mag(1, :), 'Color', colors(ch,:), 'LineWidth', 2);
    %end
    xlabel('Frequency (Hz)');
    ylabel('Magnitude');
    title('Average FFT Magnitude Spectrum per Channel');
    legend(arrayfun(@(x) sprintf('Channel %d', x), 1:num_channels, 'UniformOutput', false));
    grid on;
    hold off;
    %freqz(b, a, 1024, Fs);
    %title('Butterworth Bandpass Filter Frequency Response');

    colors = lines(num_channels);
    figure; hold on;
    
    for ch = 1:num_channels
        for w = 1:num_windows
            t = window_times{w} / 1000;       % convert ms to seconds
            y = filtered_windows{w}(:, ch);   % filtered data for window w, channel ch
            plot(t, y, 'Color', colors(ch,:), 'LineWidth', 0.5);
        end
    end
    
    xlabel('Time (s)');
    ylabel('Amplitude (V)');
    title('Filtered EMG Windows (All Channels)');
    legend(arrayfun(@(x) sprintf('Channel %d', x), 1:num_channels, 'UniformOutput', false));
    grid on;
    hold off;